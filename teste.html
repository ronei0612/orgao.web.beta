<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Detector Vocal (Filtro de Voz)</title>
    <style>
        :root {
            --bg-color: #121212;
            --text-color: #ffffff;
            --accent-color: #00d4ff;
            --btn-start: #1db954;
            --btn-stop: #ff4d4d;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
            user-select: none;
        }

        .container {
            text-align: center;
            width: 100%;
            max-width: 400px;
            padding: 20px;
        }

        h1 {
            font-size: 1rem;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 20px;
        }

        .note-display {
            font-size: 7rem;
            font-weight: bold;
            color: var(--accent-color);
            text-shadow: 0 0 20px rgba(0, 212, 255, 0.2);
            height: 140px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: color 0.2s;
        }

        .frequency {
            font-size: 1.2rem;
            color: #888;
            margin-bottom: 30px;
            font-family: monospace;
            height: 24px;
        }

        /* Indicador de Afinação */
        .tuner-bar {
            width: 80%;
            height: 6px;
            background: #333;
            border-radius: 3px;
            position: relative;
            margin: 0 auto 40px auto;
        }

        .tuner-marker {
            width: 2px;
            height: 14px;
            background: #fff;
            position: absolute;
            left: 50%;
            top: -4px;
            transform: translateX(-50%);
        }

        .tuner-dot {
            width: 16px;
            height: 16px;
            background: var(--accent-color);
            border-radius: 50%;
            position: absolute;
            top: -5px;
            left: 50%;
            transform: translateX(-50%);
            transition: left 0.1s ease-out, background-color 0.2s;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }

        /* Botão */
        .mic-button {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            border: none;
            background-color: var(--btn-start);
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto;
            outline: none;
            -webkit-tap-highlight-color: transparent;
            transition: transform 0.1s;
        }

            .mic-button:active {
                transform: scale(0.95);
            }

            .mic-button.listening {
                background-color: var(--btn-stop);
                animation: pulse 1.5s infinite;
            }

        .mic-icon {
            width: 28px;
            height: 28px;
            fill: white;
        }

        .status-text {
            margin-top: 15px;
            font-size: 0.9rem;
            color: #666;
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(255, 77, 77, 0.7);
            }

            70% {
                box-shadow: 0 0 0 15px rgba(255, 77, 77, 0);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(255, 77, 77, 0);
            }
        }
    </style>
</head>
<body>

    <div class="container">
        <h1>Afinador Vocal</h1>

        <div class="note-display" id="note">--</div>

        <div class="tuner-bar">
            <div class="tuner-marker"></div>
            <div class="tuner-dot" id="indicator"></div>
        </div>

        <div class="frequency" id="freq">Silêncio</div>

        <button class="mic-button" id="micBtn">
            <svg class="mic-icon" viewBox="0 0 24 24">
                <path d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3z" />
                <path d="M17 11c0 2.76-2.24 5-5 5s-5-2.24-5-5H5c0 3.53 2.61 6.43 6 6.92V21h2v-3.08c3.39-.49 6-3.39 6-6.92h-2z" />
            </svg>
        </button>
        <div class="status-text" id="status">Toque para iniciar</div>
    </div>

    <script>
        const noteStrings = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
        let audioContext = null;
        let analyser = null;
        let isListening = false;
        let animationId = null;

        // --- CONFIGURAÇÕES DE SENSIBILIDADE ---
        const NOISE_THRESHOLD = 0.02; // Aumente para 0.03 ou 0.05 se ainda captar muito ruído
        const MIN_FREQ = 80;   // Frequência mínima (Grave humano)
        const MAX_FREQ = 1100; // Frequência máxima (Agudo humano - Soprano C6 é ~1046Hz)
        const SMOOTHING_THRESHOLD = 5; // Quantos frames a nota precisa se manter para aparecer na tela

        let lastNoteBuffer = [];

        const noteElem = document.getElementById("note");
        const freqElem = document.getElementById("freq");
        const statusElem = document.getElementById("status");
        const btnElem = document.getElementById("micBtn");
        const indicatorElem = document.getElementById("indicator");

        btnElem.addEventListener("click", toggleMic);

        async function toggleMic() {
            if (isListening) {
                stopListening();
            } else {
                await startListening();
            }
        }

        async function startListening() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: false
                    }
                });

                const source = audioContext.createMediaStreamSource(stream);
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 2048;
                source.connect(analyser);

                isListening = true;
                btnElem.classList.add("listening");
                statusElem.innerText = "Cante uma nota...";
                updatePitch();
            } catch (err) {
                alert("Erro: Permissão negada ou ambiente inseguro (use HTTPS).");
            }
        }

        function stopListening() {
            isListening = false;
            btnElem.classList.remove("listening");
            statusElem.innerText = "Toque para iniciar";
            noteElem.innerText = "--";
            freqElem.innerText = "Silêncio";
            indicatorElem.style.left = "50%";
            indicatorElem.style.backgroundColor = "var(--accent-color)";
            if (animationId) cancelAnimationFrame(animationId);
            if (audioContext) audioContext.close();
        }

        function autoCorrelate(buf, sampleRate) {
            let SIZE = buf.length;
            let rms = 0;

            // 1. Checa Volume (Gate de Ruído)
            for (let i = 0; i < SIZE; i++) {
                rms += buf[i] * buf[i];
            }
            rms = Math.sqrt(rms / SIZE);

            // Se o som for menor que o limite configurado, ignora
            if (rms < NOISE_THRESHOLD) return -1;

            // 2. Algoritmo de Autocorrelação
            let r1 = 0, r2 = SIZE - 1, thres = 0.2;
            for (let i = 0; i < SIZE / 2; i++) {
                if (Math.abs(buf[i]) < thres) { r1 = i; break; }
            }
            for (let i = 1; i < SIZE / 2; i++) {
                if (Math.abs(buf[SIZE - i]) < thres) { r2 = SIZE - i; break; }
            }

            buf = buf.slice(r1, r2);
            SIZE = buf.length;

            let c = new Array(SIZE).fill(0);
            for (let i = 0; i < SIZE; i++) {
                for (let j = 0; j < SIZE - i; j++) {
                    c[i] = c[i] + buf[j] * buf[j + i];
                }
            }

            let d = 0; while (c[d] > c[d + 1]) d++;
            let maxval = -1, maxpos = -1;
            for (let i = d; i < SIZE; i++) {
                if (c[i] > maxval) {
                    maxval = c[i];
                    maxpos = i;
                }
            }
            let T0 = maxpos;

            let x1 = c[T0 - 1], x2 = c[T0], x3 = c[T0 + 1];
            let a = (x1 + x3 - 2 * x2) / 2;
            let b = (x3 - x1) / 2;
            if (a) T0 = T0 - b / (2 * a);

            return sampleRate / T0;
        }

        function updatePitch() {
            if (!isListening) return;

            const buf = new Float32Array(analyser.fftSize);
            analyser.getFloatTimeDomainData(buf);

            const pitch = autoCorrelate(buf, audioContext.sampleRate);

            // Filtros de lógica
            if (pitch === -1 || pitch < MIN_FREQ || pitch > MAX_FREQ) {
                // Se não detectar nada ou estiver fora do alcance vocal
                // Mantém a última nota por um instante ou reseta lentamente
                // (Aqui optamos por não atualizar a tela se for ruído rápido)
            } else {
                const noteNum = 12 * (Math.log(pitch / 440) / Math.log(2));
                const noteRounded = Math.round(noteNum) + 69;
                const value = noteRounded % 12;

                if (!isNaN(value)) {
                    // Estabilização: Adiciona nota ao buffer
                    lastNoteBuffer.push(value);
                    if (lastNoteBuffer.length > SMOOTHING_THRESHOLD) {
                        lastNoteBuffer.shift(); // Remove a antiga
                    }

                    // Checa se todas as notas no buffer são iguais (estabilidade)
                    const isStable = lastNoteBuffer.every(v => v === lastNoteBuffer[0]);

                    if (isStable) {
                        const noteName = noteStrings[value];
                        noteElem.innerText = noteName;
                        freqElem.innerText = Math.round(pitch) + " Hz";

                        // Visualização
                        const cents = Math.floor(1200 * (Math.log(pitch / frequencyFromNoteNumber(noteRounded)) / Math.log(2)));
                        let visualPosition = 50 + (cents / 50) * 45;

                        // Trava a bolinha nas bordas
                        if (visualPosition > 95) visualPosition = 95;
                        if (visualPosition < 5) visualPosition = 5;

                        indicatorElem.style.left = visualPosition + "%";

                        // Muda cor se afinado
                        if (Math.abs(cents) < 10) {
                            noteElem.style.color = "#1db954";
                            indicatorElem.style.backgroundColor = "#1db954";
                        } else {
                            noteElem.style.color = "#00d4ff";
                            indicatorElem.style.backgroundColor = "#00d4ff";
                        }
                    }
                }
            }

            animationId = requestAnimationFrame(updatePitch);
        }

        function frequencyFromNoteNumber(note) {
            return 440 * Math.pow(2, (note - 69) / 12);
        }
    </script>
</body>
</html>