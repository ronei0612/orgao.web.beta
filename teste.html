<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Detector de Notas Musicais</title>
    <style>
        :root {
            --bg-color: #121212;
            --text-color: #ffffff;
            --accent-color: #00d4ff;
            --secondary-color: #2c2c2c;
            --btn-start: #1db954;
            --btn-stop: #ff4d4d;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
        }

        .container {
            text-align: center;
            width: 100%;
            max-width: 400px;
            padding: 20px;
            box-sizing: border-box;
        }

        h1 {
            font-size: 1.2rem;
            color: #888;
            margin-bottom: 30px;
            font-weight: 300;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        /* Display da Nota Principal */
        .note-display {
            font-size: 8rem;
            font-weight: bold;
            color: var(--accent-color);
            text-shadow: 0 0 20px rgba(0, 212, 255, 0.3);
            min-height: 150px;
            line-height: 1;
            margin: 10px 0;
        }

        .frequency {
            font-size: 1.5rem;
            color: #888;
            margin-bottom: 40px;
            font-family: monospace;
        }

        /* Botão Central */
        .mic-button {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            border: none;
            background-color: var(--btn-start);
            color: white;
            font-size: 1.5rem;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto;
            outline: none;
            -webkit-tap-highlight-color: transparent;
        }

            .mic-button:active {
                transform: scale(0.95);
            }

            .mic-button.listening {
                background-color: var(--btn-stop);
                animation: pulse 1.5s infinite;
            }

        .mic-icon {
            width: 30px;
            height: 30px;
            fill: white;
        }

        .status-text {
            margin-top: 15px;
            font-size: 0.9rem;
            color: #666;
        }

        /* Animação de pulso */
        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(255, 77, 77, 0.7);
            }

            70% {
                box-shadow: 0 0 0 20px rgba(255, 77, 77, 0);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(255, 77, 77, 0);
            }
        }

        /* Barra de afinação visual */
        .tuner-bar-wrapper {
            width: 80%;
            height: 4px;
            background: #333;
            margin: 0 auto 30px auto;
            position: relative;
            border-radius: 2px;
        }

        .center-marker {
            position: absolute;
            left: 50%;
            top: -5px;
            bottom: -5px;
            width: 2px;
            background: #fff;
            transform: translateX(-50%);
        }

        .tuner-indicator {
            position: absolute;
            left: 50%;
            top: -4px;
            width: 12px;
            height: 12px;
            background: var(--accent-color);
            border-radius: 50%;
            transform: translateX(-50%);
            transition: left 0.1s ease-out;
        }
    </style>
</head>
<body>

    <div class="container">
        <h1>Detector Vocal</h1>

        <div class="note-display" id="note">--</div>

        <div class="tuner-bar-wrapper">
            <div class="center-marker"></div>
            <div class="tuner-indicator" id="indicator"></div>
        </div>

        <div class="frequency" id="freq">0 Hz</div>

        <button class="mic-button" id="micBtn">
            <!-- Ícone de Microfone SVG -->
            <svg class="mic-icon" viewBox="0 0 24 24">
                <path d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3z" />
                <path d="M17 11c0 2.76-2.24 5-5 5s-5-2.24-5-5H5c0 3.53 2.61 6.43 6 6.92V21h2v-3.08c3.39-.49 6-3.39 6-6.92h-2z" />
            </svg>
        </button>
        <div class="status-text" id="status">Toque para começar</div>
    </div>

    <script>
        // Configurações Globais
        const noteStrings = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
        let audioContext = null;
        let analyser = null;
        let mediaStreamSource = null;
        let isListening = false;
        let animationId = null;

        // Elementos do DOM
        const noteElem = document.getElementById("note");
        const freqElem = document.getElementById("freq");
        const statusElem = document.getElementById("status");
        const btnElem = document.getElementById("micBtn");
        const indicatorElem = document.getElementById("indicator");

        btnElem.addEventListener("click", toggleMic);

        async function toggleMic() {
            if (isListening) {
                stopListening();
            } else {
                await startListening();
            }
        }

        async function startListening() {
            try {
                // Inicializa o AudioContext (necessário interação do usuário)
                audioContext = new (window.AudioContext || window.webkitAudioContext)();

                // Pede permissão do microfone
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });

                mediaStreamSource = audioContext.createMediaStreamSource(stream);
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 2048; // Tamanho do buffer para análise
                mediaStreamSource.connect(analyser);

                isListening = true;
                btnElem.classList.add("listening");
                statusElem.innerText = "Escutando...";
                updatePitch();
            } catch (err) {
                console.error(err);
                alert("Erro ao acessar microfone. Verifique as permissões ou use HTTPS.");
            }
        }

        function stopListening() {
            isListening = false;
            btnElem.classList.remove("listening");
            statusElem.innerText = "Toque para começar";
            noteElem.innerText = "--";
            freqElem.innerText = "0 Hz";

            // Centraliza o indicador
            indicatorElem.style.left = "50%";

            if (animationId) cancelAnimationFrame(animationId);
            if (audioContext && audioContext.state !== 'closed') {
                audioContext.close();
            }
        }

        // Algoritmo de Autocorrelação para detectar Pitch (Melhor para voz humana que FFT simples)
        function autoCorrelate(buf, sampleRate) {
            let SIZE = buf.length;
            let rms = 0;

            // 1. Calcula Volume (RMS) para ignorar ruído
            for (let i = 0; i < SIZE; i++) {
                let val = buf[i];
                rms += val * val;
            }
            rms = Math.sqrt(rms / SIZE);

            // Se o som for muito baixo, retorna -1
            if (rms < 0.01) return -1;

            // 2. Autocorrelação
            let r1 = 0, r2 = SIZE - 1, thres = 0.2;
            for (let i = 0; i < SIZE / 2; i++) {
                if (Math.abs(buf[i]) < thres) { r1 = i; break; }
            }
            for (let i = 1; i < SIZE / 2; i++) {
                if (Math.abs(buf[SIZE - i]) < thres) { r2 = SIZE - i; break; }
            }

            buf = buf.slice(r1, r2);
            SIZE = buf.length;

            let c = new Array(SIZE).fill(0);
            for (let i = 0; i < SIZE; i++) {
                for (let j = 0; j < SIZE - i; j++) {
                    c[i] = c[i] + buf[j] * buf[j + i];
                }
            }

            let d = 0; while (c[d] > c[d + 1]) d++;
            let maxval = -1, maxpos = -1;
            for (let i = d; i < SIZE; i++) {
                if (c[i] > maxval) {
                    maxval = c[i];
                    maxpos = i;
                }
            }
            let T0 = maxpos;

            let x1 = c[T0 - 1], x2 = c[T0], x3 = c[T0 + 1];
            let a = (x1 + x3 - 2 * x2) / 2;
            let b = (x3 - x1) / 2;
            if (a) T0 = T0 - b / (2 * a);

            return sampleRate / T0;
        }

        function updatePitch() {
            if (!isListening) return;

            const buf = new Float32Array(analyser.fftSize);
            analyser.getFloatTimeDomainData(buf);

            const ac = autoCorrelate(buf, audioContext.sampleRate);

            if (ac === -1) {
                // Som muito baixo ou indefinido (mantém a tela estável ou limpa um pouco)
                // indicatorElem.style.left = "50%"; // Opcional: resetar indicador
            } else {
                const pitch = ac;
                freqElem.innerText = Math.round(pitch) + " Hz";

                // Converte Frequência para Nota Musical
                const noteNum = 12 * (Math.log(pitch / 440) / Math.log(2));
                const noteRounded = Math.round(noteNum) + 69;
                const value = noteRounded % 12;

                // Evita erro se o cálculo for infinito/NaN
                if (!isNaN(value)) {
                    noteElem.innerText = noteStrings[value];

                    // Visualização de Afinação (Cents)
                    // Calcula o desvio (cents) para mover a bolinha
                    const cents = Math.floor(1200 * (Math.log(pitch / frequencyFromNoteNumber(noteRounded)) / Math.log(2)));

                    // Limita o movimento visual a +/- 45% do centro
                    let visualPosition = 50 + (cents / 50) * 45;
                    if (visualPosition > 95) visualPosition = 95;
                    if (visualPosition < 5) visualPosition = 5;

                    indicatorElem.style.left = visualPosition + "%";

                    // Muda a cor se estiver afinado (dentro de 5 cents)
                    if (Math.abs(cents) < 10) {
                        noteElem.style.color = "#1db954"; // Verde
                        indicatorElem.style.background = "#1db954";
                    } else {
                        noteElem.style.color = "#00d4ff"; // Azul original
                        indicatorElem.style.background = "#00d4ff";
                    }
                }
            }

            animationId = requestAnimationFrame(updatePitch);
        }

        function frequencyFromNoteNumber(note) {
            return 440 * Math.pow(2, (note - 69) / 12);
        }
    </script>
</body>
</html>