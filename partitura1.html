<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Editor de Partitura Preciso</title>
    <script src="https://cdn.jsdelivr.net/npm/vexflow@4.2.2/build/cjs/vexflow.js"></script>
    <style>
        body {
            font-family: sans-serif;
            margin: 0;
            overflow: hidden;
            touch-action: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f0f0f0;
        }

        #controls {
            padding: 15px;
            background: #333;
            color: white;
            width: 100%;
            text-align: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        #score-container {
            background: white;
            margin-top: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
        }

        button {
            margin: 5px;
            padding: 10px 15px;
            cursor: pointer;
        }
    </style>
</head>
<body>

    <div id="controls">
        <strong>Editor VexFlow Mobile</strong><br>
        <button onclick="deleteLastNote()">Apagar Última</button>
        <button onclick="clearScore()">Limpar Tudo</button>
    </div>

    <div id="score-container"></div>

    <script>
        const { Renderer, Stave, StaveNote, Voice, Formatter } = Vex.Flow;

        const container = document.getElementById('score-container');
        const width = window.innerWidth * 0.95;
        const height = 200;

        let notesData = [
            { key: "c/4", duration: "q" },
            { key: "e/4", duration: "q" },
            { key: "g/4", duration: "q" }
        ];

        let noteXPositions = []; // Guardará a posição X exata de cada nota desenhada
        let isDragging = false;
        let selectedNoteIndex = -1;

        // Notas mapeadas por índice (0 é B/4 - a linha central da clave de sol)
        const basePitches = ["c/4", "d/4", "e/4", "f/4", "g/4", "a/4", "b/4", "c/5", "d/5", "e/5", "f/5", "g/5", "a/5"];

        function draw() {
            container.innerHTML = "";
            const renderer = new Renderer(container, Renderer.Backends.SVG);
            renderer.resize(width, height);
            const context = renderer.getContext();

            // A pauta começa em y=40. O VexFlow tem 5 linhas com 10px de espaço.
            // Linhas: 40, 50, 60, 70, 80. A linha central (Si4) está em 60.
            const stave = new Stave(10, 40, width - 20);
            stave.addClef("treble").addTimeSignature("4/4");
            stave.setContext(context).draw();

            const vexNotes = notesData.map((data, index) => {
                const note = new StaveNote({ keys: [data.key], duration: data.duration });
                if (index === selectedNoteIndex) {
                    note.setStyle({ fillStyle: "red", strokeStyle: "red" });
                }
                return note;
            });

            if (vexNotes.length > 0) {
                const voice = new Voice({ num_beats: vexNotes.length, beat_value: 4 });
                voice.setStrict(false);
                voice.addTickables(vexNotes);

                new Formatter().joinVoices([voice]).format([voice], width - 100);
                voice.draw(context, stave);

                // IMPORTANTE: Captura a posição X real de cada nota após o Formatter posicioná-las
                noteXPositions = vexNotes.map(n => n.getAbsoluteX());
            }
        }

        function getYToPitch(y) {
            // Ajuste fino: A linha central (B/4) no stave(10, 40) fica em Y = 90 no sistema de coordenadas do SVG
            // (40 do offset + 50 que é o meio da pauta de 100px)
            const centerY = 90;
            const stepHeight = 5; // Cada nota/espaço na pauta VexFlow tem 5px de altura

            const diff = Math.round((centerY - y) / stepHeight);
            const b4Index = 6; // Índice de "b/4" no array basePitches
            let newIndex = b4Index + diff;

            newIndex = Math.max(0, Math.min(newIndex, basePitches.length - 1));
            return basePitches[newIndex];
        }

        function handleStart(e) {
            const rect = container.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            const x = clientX - rect.left;
            const y = clientY - rect.top;

            // Busca se o clique foi perto de alguma nota existente (raio de 20px)
            let foundIndex = -1;
            for (let i = 0; i < noteXPositions.length; i++) {
                if (Math.abs(x - noteXPositions[i]) < 20) {
                    foundIndex = i;
                    break;
                }
            }

            if (foundIndex !== -1) {
                // Seleciona nota existente
                selectedNoteIndex = foundIndex;
            } else if (x > (noteXPositions[noteXPositions.length - 1] || 50) + 10) {
                // Adiciona nova nota se clicar à direita da última
                notesData.push({ key: getYToPitch(y), duration: "q" });
                selectedNoteIndex = notesData.length - 1;
            }

            isDragging = true;
            draw();
        }

        function handleMove(e) {
            if (!isDragging || selectedNoteIndex === -1) return;
            e.preventDefault();

            const rect = container.getBoundingClientRect();
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            const y = clientY - rect.top;

            const newPitch = getYToPitch(y);
            if (notesData[selectedNoteIndex].key !== newPitch) {
                notesData[selectedNoteIndex].key = newPitch;
                draw();
            }
        }

        function handleEnd() {
            isDragging = false;
            selectedNoteIndex = -1;
            draw();
        }

        function deleteLastNote() {
            notesData.pop();
            draw();
        }

        function clearScore() {
            notesData = [];
            draw();
        }

        container.addEventListener('mousedown', handleStart);
        window.addEventListener('mousemove', handleMove);
        window.addEventListener('mouseup', handleEnd);

        container.addEventListener('touchstart', handleStart, { passive: false });
        window.addEventListener('touchmove', handleMove, { passive: false });
        window.addEventListener('touchend', handleEnd);

        draw();
    </script>
</body>
</html>